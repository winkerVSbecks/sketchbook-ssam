import Random from 'canvas-sketch-util/random';
import { mapRange } from 'canvas-sketch-util/math';
import { Delaunay } from 'd3-delaunay';
import { Domain, RelativePolygon, RelativePolygonVertex } from './types';

/**
 * Generates a convex polygon from a set of regions.
 * The polygon is generated by finding a random location within each region
 *  and sorting their vertices in clockwise order. If the resulting polygon
 * is not convex, the process is repeated.
 */
export function generatePolygon(
  regions: Domain[],
  attempts: number = 0
): Point[] {
  if (attempts > 100) {
    throw new Error('Failed to generate a convex polygon');
  }

  let polygon: Point[] = regions.map((r) => [
    Random.range(r.x, r.x + r.width),
    Random.range(r.y, r.y + r.height),
  ]);

  // Calculate centroid
  const centroid = polygon
    .reduce((acc, point) => [acc[0] + point[0], acc[1] + point[1]], [0, 0])
    .map((coord) => coord / polygon.length);

  // Sort points clockwise
  polygon = polygon.sort((a, b) => {
    const angleA = Math.atan2(a[1] - centroid[1], a[0] - centroid[0]);
    const angleB = Math.atan2(b[1] - centroid[1], b[0] - centroid[0]);
    return angleA - angleB; // Clockwise sorting
  });

  return isConvexPolygon(polygon)
    ? polygon
    : generatePolygon(regions, attempts + 1);
}

export function generateRelativePolygon(
  regions: Domain[],
  attempts: number = 0
): RelativePolygon {
  if (attempts > 100) {
    throw new Error('Failed to generate a convex polygon');
  }

  let polygon: RelativePolygon = regions.map((r) => {
    return {
      domain: r,
      point: [
        Random.range(r.x, r.x + r.width),
        Random.range(r.y, r.y + r.height),
      ],
    };
  });

  // Calculate centroid
  const centroid = polygon
    .reduce((acc, p) => [acc[0] + p.point[0], acc[1] + p.point[1]], [0, 0])
    .map((coord) => coord / polygon.length);

  // Sort points clockwise
  polygon = polygon.sort((a, b) => {
    const angleA = Math.atan2(
      a.point[1] - centroid[1],
      a.point[0] - centroid[0]
    );
    const angleB = Math.atan2(
      b.point[1] - centroid[1],
      b.point[0] - centroid[0]
    );
    return angleA - angleB; // Clockwise sorting
  });

  return isConvexPolygon(polygon.map((p) => p.point))
    ? polygon.map(({ domain, point }: RelativePolygonVertex) => ({
        domain,
        point: [
          mapRange(point[0], domain.x, domain.x + domain.width, 0, 1),
          mapRange(point[1], domain.y, domain.y + domain.height, 0, 1),
        ] as Point,
      }))
    : generateRelativePolygon(regions, attempts + 1);
}

/**
 * Checks if a polygon is convex.
 * A polygon is convex if all interior angles are less than 180 degrees,
 * which can be determined by checking if all cross products of consecutive edges have the same sign.
 */
function isConvexPolygon(vertices: Point[]): boolean {
  // A polygon needs at least 3 vertices
  if (vertices.length < 3) {
    return false;
  }

  // For a convex polygon, all cross products of consecutive edges should have the same sign
  let sign = 0;

  const n = vertices.length;

  for (let i = 0; i < n; i++) {
    const current = vertices[i];
    const next = vertices[(i + 1) % n];
    const afterNext = vertices[(i + 2) % n];

    // Calculate vectors for two consecutive edges
    const edge1 = [next[0] - current[0], next[1] - current[1]];
    const edge2 = [afterNext[0] - next[0], afterNext[1] - next[1]];

    // Calculate cross product (in 2D, it's a scalar: edge1.x * edge2.y - edge1.y * edge2.x)
    const crossProduct = edge1[0] * edge2[1] - edge1[1] * edge2[0];

    // On the first valid cross product, store its sign
    if (crossProduct !== 0) {
      if (sign === 0) {
        sign = Math.sign(crossProduct);
      }
      // If we find a cross product with different sign, the polygon is not convex
      else if (sign * crossProduct < 0) {
        return false;
      }
    }
  }

  return true;
}

export function generateTessellatedPolygon(
  regions: Domain[]
): RelativePolygon[] {
  const points = regions
    .map((r) => {
      const pts = [];
      for (let index = 0; index < 1; index++) {
        pts.push({
          domain: r,
          point: [
            Random.range(r.x, r.x + r.width),
            Random.range(r.y, r.y + r.height),
          ],
        });
      }
      return pts;
    })
    .flat();

  const delaunay = new Delaunay(points.map((p) => p.point).flat());

  let triangles: [number, number, number][] = [];

  for (let i = 0; i < delaunay.triangles.length; i += 3) {
    const t0 = delaunay.triangles[i];
    const t1 = delaunay.triangles[i + 1];
    const t2 = delaunay.triangles[i + 2];
    triangles.push([t0, t1, t2]);
  }

  const polygons: RelativePolygon[] = triangles.map((triangle) => {
    return triangle.map((point) => {
      const pt = points[point];
      const domain = pt.domain;

      return {
        domain,
        point: [
          mapRange(pt.point[0], domain.x, domain.x + domain.width, 0, 1),
          mapRange(pt.point[1], domain.y, domain.y + domain.height, 0, 1),
        ],
      };
    });
  });

  return polygons;
}

export function addPaddingToPolygon(
  vertices: Point[],
  padding: number
): Point[] {
  const result = [];
  const n = vertices.length;

  for (let i = 0; i < n; i++) {
    const prev = vertices[(i - 1 + n) % n];
    const curr = vertices[i];
    const next = vertices[(i + 1) % n];

    // Calculate inward normal direction
    const edge1 = [curr[0] - prev[0], curr[1] - prev[1]];
    const edge2 = [next[0] - curr[0], next[1] - curr[1]];

    // Average the normals of adjacent edges
    const normal1 = [-edge1[1], edge1[0]]; // perpendicular
    const normal2 = [-edge2[1], edge2[0]];

    // Normalize and average
    const len1 = Math.sqrt(normal1[0] ** 2 + normal1[1] ** 2);
    const len2 = Math.sqrt(normal2[0] ** 2 + normal2[1] ** 2);

    const avgNormal = [
      (normal1[0] / len1 + normal2[0] / len2) / 2,
      (normal1[1] / len1 + normal2[1] / len2) / 2,
    ];

    const avgLen = Math.sqrt(avgNormal[0] ** 2 + avgNormal[1] ** 2);

    // Move vertex inward by padding amount
    result.push([
      curr[0] - (avgNormal[0] / avgLen) * padding,
      curr[1] - (avgNormal[1] / avgLen) * padding,
    ] as Point);
  }

  return result;
}
